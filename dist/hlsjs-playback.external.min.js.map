{"version":3,"file":"hlsjs-playback.external.min.js","sources":["../src/hls.js"],"sourcesContent":["// Copyright 2014 Globo.com Player authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\nimport { Events, HTML5Video, Log, Playback, PlayerError, Utils } from '@clappr/core'\nimport HLSJS from 'hls.js'\n\nconst { now, assign, listContainsIgnoreCase } = Utils\n\nconst AUTO = -1\n\nEvents.register('PLAYBACK_FRAGMENT_CHANGED')\nEvents.register('PLAYBACK_FRAGMENT_PARSING_METADATA')\n\nexport default class HlsjsPlayback extends HTML5Video {\n  get name() { return 'hls' }\n\n  get supportedVersion() { return { min: CLAPPR_CORE_VERSION } }\n\n  get levels() { return this._levels || [] }\n\n  get currentLevel() {\n    if (this._currentLevel === null || this._currentLevel === undefined)\n      return AUTO\n    else\n      return this._currentLevel //0 is a valid level ID\n\n  }\n\n  get isReady() {\n    return this._isReadyState\n  }\n\n  set currentLevel(id) {\n    this._currentLevel = id\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_START)\n    if (this.options.playback.hlsUseNextLevel)\n      this._hls.nextLevel = this._currentLevel\n    else\n      this._hls.currentLevel = this._currentLevel\n  }\n\n  get _startTime() {\n    if (this._playbackType === Playback.LIVE && this._playlistType !== 'EVENT')\n      return this._extrapolatedStartTime\n\n    return this._playableRegionStartTime\n  }\n\n  get _now() {\n    return now()\n  }\n\n  // the time in the video element which should represent the start of the sliding window\n  // extrapolated to increase in real time (instead of jumping as the early segments are removed)\n  get _extrapolatedStartTime() {\n    if (!this._localStartTimeCorrelation)\n      return this._playableRegionStartTime\n\n    let corr = this._localStartTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedWindowStartTime = (corr.remote + timePassed) / 1000\n    // cap at the end of the extrapolated window duration\n    return Math.min(extrapolatedWindowStartTime, this._playableRegionStartTime + this._extrapolatedWindowDuration)\n  }\n\n  // the time in the video element which should represent the end of the content\n  // extrapolated to increase in real time (instead of jumping as segments are added)\n  get _extrapolatedEndTime() {\n    let actualEndTime = this._playableRegionStartTime + this._playableRegionDuration\n    if (!this._localEndTimeCorrelation)\n      return actualEndTime\n\n    let corr = this._localEndTimeCorrelation\n    let timePassed = this._now - corr.local\n    let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n    return Math.max(actualEndTime - this._extrapolatedWindowDuration, Math.min(extrapolatedEndTime, actualEndTime))\n  }\n\n  get _duration() {\n    return this._extrapolatedEndTime - this._startTime\n  }\n\n  // Returns the duration (seconds) of the window that the extrapolated start time is allowed\n  // to move in before being capped.\n  // The extrapolated start time should never reach the cap at the end of the window as the\n  // window should slide as chunks are removed from the start.\n  // This also applies to the extrapolated end time in the same way.\n  //\n  // If chunks aren't being removed for some reason that the start time will reach and remain fixed at\n  // playableRegionStartTime + extrapolatedWindowDuration\n  //\n  //                                <-- window duration -->\n  // I.e   playableRegionStartTime |-----------------------|\n  //                               | -->   .       .       .\n  //                               .   --> | -->   .       .\n  //                               .       .   --> | -->   .\n  //                               .       .       .   --> |\n  //                               .       .       .       .\n  //                                 extrapolatedStartTime\n  get _extrapolatedWindowDuration() {\n    if (this._segmentTargetDuration === null)\n      return 0\n\n    return this._extrapolatedWindowNumSegments * this._segmentTargetDuration\n  }\n\n  get bandwidthEstimate() {\n    return this._hls && this._hls.bandwidthEstimate\n  }\n\n  get defaultOptions() {\n    return { preload: true }\n  }\n\n  get customListeners() {\n    return this.options.hlsPlayback && this.options.hlsPlayback.customListeners || []\n  }\n\n  static get HLSJS() {\n    return HLSJS\n  }\n\n  constructor(...args) {\n    super(...args)\n    // backwards compatibility (TODO: remove on 0.3.0)\n    this.options.playback = { ...this.options, ...this.options.playback }\n    this.options.hlsPlayback = { ...this.defaultOptions, ...this.options.hlsPlayback }\n    this._minDvrSize = typeof (this.options.hlsMinimumDvrSize) === 'undefined' ? 60 : this.options.hlsMinimumDvrSize\n    // The size of the start time extrapolation window measured as a multiple of segments.\n    // Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is\n    // removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are\n    // added/removed every 5.\n    this._extrapolatedWindowNumSegments = !this.options.playback || typeof (this.options.playback.extrapolatedWindowNumSegments) === 'undefined' ? 2 :  this.options.playback.extrapolatedWindowNumSegments\n\n    this._playbackType = Playback.VOD\n    this._lastTimeUpdate = { current: 0, total: 0 }\n    this._lastDuration = null\n    // for hls streams which have dvr with a sliding window,\n    // the content at the start of the playlist is removed as new\n    // content is appended at the end.\n    // this means the actual playable start time will increase as the\n    // start content is deleted\n    // For streams with dvr where the entire recording is kept from the\n    // beginning this should stay as 0\n    this._playableRegionStartTime = 0\n    // {local, remote} remote is the time in the video element that should represent 0\n    //                 local is the system time when the 'remote' measurment took place\n    this._localStartTimeCorrelation = null\n    // {local, remote} remote is the time in the video element that should represents the end\n    //                 local is the system time when the 'remote' measurment took place\n    this._localEndTimeCorrelation = null\n    // if content is removed from the beginning then this empty area should\n    // be ignored. \"playableRegionDuration\" excludes the empty area\n    this._playableRegionDuration = 0\n    // #EXT-X-PROGRAM-DATE-TIME\n    this._programDateTime = 0\n    // true when the actual duration is longer than hlsjs's live sync point\n    // when this is false playableRegionDuration will be the actual duration\n    // when this is true playableRegionDuration will exclude the time after the sync point\n    this._durationExcludesAfterLiveSyncPoint = false\n    // #EXT-X-TARGETDURATION\n    this._segmentTargetDuration = null\n    // #EXT-X-PLAYLIST-TYPE\n    this._playlistType = null\n    this._recoverAttemptsRemaining = this.options.hlsRecoverAttempts || 16\n  }\n\n  _setup() {\n    this._manifestParsed = false\n    this._ccIsSetup = false\n    this._ccTracksUpdated = false\n    this._hls && this._hls.destroy()\n    this._hls = new HLSJS(assign({}, this.options.playback.hlsjsConfig))\n    this._hls.once(HLSJS.Events.MEDIA_ATTACHED, () => { this.options.hlsPlayback.preload && this._hls.loadSource(this.options.src) })\n    this._hls.on(HLSJS.Events.MANIFEST_PARSED, () => this._manifestParsed = true)\n    this._hls.on(HLSJS.Events.LEVEL_LOADED, (evt, data) => this._updatePlaybackType(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_UPDATED, (evt, data) => this._onLevelUpdated(evt, data))\n    this._hls.on(HLSJS.Events.LEVEL_SWITCHING, (evt,data) => this._onLevelSwitch(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_CHANGED, (evt, data) => this._onFragmentChanged(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_LOADED, (evt, data) => this._onFragmentLoaded(evt, data))\n    this._hls.on(HLSJS.Events.FRAG_PARSING_METADATA, (evt, data) => this._onFragmentParsingMetadata(evt, data))\n    this._hls.on(HLSJS.Events.ERROR, (evt, data) => this._onHLSJSError(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACK_LOADED, (evt, data) => this._onSubtitleLoaded(evt, data))\n    this._hls.on(HLSJS.Events.SUBTITLE_TRACKS_UPDATED, () => this._ccTracksUpdated = true)\n\n    this.bindCustomListeners()\n\n    this._hls.attachMedia(this.el)\n  }\n\n  bindCustomListeners() {\n    this.customListeners.forEach(item => {\n      const requestedEventName = item.eventName\n      const typeOfListener = item.once ? 'once': 'on'\n      requestedEventName && this._hls[`${typeOfListener}`](requestedEventName, item.callback)\n    })\n  }\n\n  unbindCustomListeners() {\n    this.customListeners.forEach(item => {\n      const requestedEventName = item.eventName\n      requestedEventName && this._hls.off(requestedEventName, item.callback)\n    })\n  }\n\n  _onFragmentParsingMetadata(evt, data) {\n    this.trigger(Events.Custom.PLAYBACK_FRAGMENT_PARSING_METADATA, { evt, data })\n  }\n\n  render() {\n    this._ready()\n    return super.render()\n  }\n\n  _ready() {\n    if (this._isReadyState) return\n    !this._hls && this._setup()\n    this._isReadyState = true\n    this.trigger(Events.PLAYBACK_READY, this.name)\n  }\n\n  _recover(evt, data, error) {\n    if (!this._recoveredDecodingError) {\n      this._recoveredDecodingError = true\n      this._hls.recoverMediaError()\n    } else if (!this._recoveredAudioCodecError) {\n      this._recoveredAudioCodecError = true\n      this._hls.swapAudioCodec()\n      this._hls.recoverMediaError()\n    } else {\n      Log.error('hlsjs: failed to recover', { evt, data })\n      error.level = PlayerError.Levels.FATAL\n      const formattedError = this.createError(error)\n      this.trigger(Events.PLAYBACK_ERROR, formattedError)\n      this.stop()\n    }\n  }\n\n  // override\n  _setupSrc(srcUrl) { // eslint-disable-line no-unused-vars\n    // this playback manages the src on the video element itself\n  }\n\n  _startTimeUpdateTimer() {\n    if (this._timeUpdateTimer) return\n\n    this._timeUpdateTimer = setInterval(() => {\n      this._onDurationChange()\n      this._onTimeUpdate()\n    }, 100)\n  }\n\n  _stopTimeUpdateTimer() {\n    if (!this._timeUpdateTimer) return\n\n    clearInterval(this._timeUpdateTimer)\n    this._timeUpdateTimer = null\n  }\n\n  getProgramDateTime() {\n    return this._programDateTime\n  }\n  // the duration on the video element itself should not be used\n  // as this does not necesarily represent the duration of the stream\n  // https://github.com/clappr/clappr/issues/668#issuecomment-157036678\n  getDuration() {\n    return this._duration\n  }\n\n  getCurrentTime() {\n    // e.g. can be < 0 if user pauses near the start\n    // eventually they will then be kicked to the end by hlsjs if they run out of buffer\n    // before the official start time\n    return Math.max(0, this.el.currentTime - this._startTime)\n  }\n\n  // the time that \"0\" now represents relative to when playback started\n  // for a stream with a sliding window this will increase as content is\n  // removed from the beginning\n  getStartTimeOffset() {\n    return this._startTime\n  }\n\n  seekPercentage(percentage) {\n    let seekTo = this._duration\n    if (percentage > 0)\n      seekTo = this._duration * (percentage / 100)\n\n    this.seek(seekTo)\n  }\n\n  seek(time) {\n    if (time < 0) {\n      Log.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.')\n      time = this.getDuration()\n    }\n    // assume live if time within 3 seconds of end of stream\n    this.dvrEnabled && this._updateDvr(time < this.getDuration()-3)\n    time += this._startTime\n    this.el.currentTime = time\n  }\n\n  seekToLivePoint() {\n    this.seek(this.getDuration())\n  }\n\n  _updateDvr(status) {\n    this.trigger(Events.PLAYBACK_DVR, status)\n    this.trigger(Events.PLAYBACK_STATS_ADD, { 'dvr': status })\n  }\n\n  _updateSettings() {\n    if (this._playbackType === Playback.VOD)\n      this.settings.left = ['playpause', 'position', 'duration']\n    else if (this.dvrEnabled)\n      this.settings.left = ['playpause']\n    else\n      this.settings.left = ['playstop']\n\n    this.settings.seekEnabled = this.isSeekEnabled()\n    this.trigger(Events.PLAYBACK_SETTINGSUPDATE)\n  }\n\n  _onHLSJSError(evt, data) {\n    const error = {\n      code: `${data.type}_${data.details}`,\n      description: `${this.name} error: type: ${data.type}, details: ${data.details}`,\n      raw: data,\n    }\n    let formattedError\n    if (data.response) error.description += `, response: ${JSON.stringify(data.response)}`\n    // only report/handle errors if they are fatal\n    // hlsjs should automatically handle non fatal errors\n    if (data.fatal) {\n      if (this._recoverAttemptsRemaining > 0) {\n        this._recoverAttemptsRemaining -= 1\n        switch (data.type) {\n        case HLSJS.ErrorTypes.NETWORK_ERROR:\n          switch (data.details) {\n          // The following network errors cannot be recovered with HLS.startLoad()\n          // For more details, see https://github.com/video-dev/hls.js/blob/master/doc/design.md#error-detection-and-handling\n          // For \"level load\" fatal errors, see https://github.com/video-dev/hls.js/issues/1138\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_ERROR:\n          case HLSJS.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          case HLSJS.ErrorDetails.MANIFEST_PARSING_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_ERROR:\n          case HLSJS.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            Log.error('hlsjs: unrecoverable network fatal error.', { evt, data })\n            formattedError = this.createError(error)\n            this.trigger(Events.PLAYBACK_ERROR, formattedError)\n            this.stop()\n            break\n          default:\n            Log.warn('hlsjs: trying to recover from network error.', { evt, data })\n            error.level = PlayerError.Levels.WARN\n            this._hls.startLoad()\n            break\n          }\n          break\n        case HLSJS.ErrorTypes.MEDIA_ERROR:\n          Log.warn('hlsjs: trying to recover from media error.', { evt, data })\n          error.level = PlayerError.Levels.WARN\n          this._recover(evt, data, error)\n          break\n        default:\n          Log.error('hlsjs: could not recover from error.', { evt, data })\n          formattedError = this.createError(error)\n          this.trigger(Events.PLAYBACK_ERROR, formattedError)\n          this.stop()\n          break\n        }\n      } else {\n        Log.error('hlsjs: could not recover from error after maximum number of attempts.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n      }\n    } else {\n      // Transforms HLSJS.ErrorDetails.KEY_LOAD_ERROR non-fatal error to\n      // playback fatal error if triggerFatalErrorOnResourceDenied playback\n      // option is set. HLSJS.ErrorTypes.KEY_SYSTEM_ERROR are fatal errors\n      // and therefore already handled.\n      if (this.options.playback.triggerFatalErrorOnResourceDenied && this._keyIsDenied(data)) {\n        Log.error('hlsjs: could not load decrypt key.', { evt, data })\n        formattedError = this.createError(error)\n        this.trigger(Events.PLAYBACK_ERROR, formattedError)\n        this.stop()\n        return\n      }\n\n      error.level = PlayerError.Levels.WARN\n      Log.warn('hlsjs: non-fatal error occurred', { evt, data })\n    }\n  }\n\n  _keyIsDenied(data) {\n    return data.type === HLSJS.ErrorTypes.NETWORK_ERROR\n      && data.details === HLSJS.ErrorDetails.KEY_LOAD_ERROR\n      && data.response\n      && data.response.code >= 400\n  }\n\n  _onTimeUpdate() {\n    let update = { current: this.getCurrentTime(), total: this.getDuration(), firstFragDateTime: this.getProgramDateTime() }\n    let isSame = this._lastTimeUpdate && (\n      update.current === this._lastTimeUpdate.current &&\n      update.total === this._lastTimeUpdate.total)\n    if (isSame)\n      return\n\n    this._lastTimeUpdate = update\n    this.trigger(Events.PLAYBACK_TIMEUPDATE, update, this.name)\n  }\n\n  _onDurationChange() {\n    let duration = this.getDuration()\n    if (this._lastDuration === duration)\n      return\n\n    this._lastDuration = duration\n    super._onDurationChange()\n  }\n\n  _onProgress() {\n    if (!this.el.buffered.length)\n      return\n\n    let buffered = []\n    let bufferedPos = 0\n    for (let i = 0; i < this.el.buffered.length; i++) {\n      buffered = [...buffered, {\n        // for a stream with sliding window dvr something that is buffered my slide off the start of the timeline\n        start: Math.max(0, this.el.buffered.start(i) - this._playableRegionStartTime),\n        end: Math.max(0, this.el.buffered.end(i) - this._playableRegionStartTime)\n      }]\n      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end)\n        bufferedPos = i\n\n    }\n    const progress = {\n      start: buffered[bufferedPos].start,\n      current: buffered[bufferedPos].end,\n      total: this.getDuration()\n    }\n    this.trigger(Events.PLAYBACK_PROGRESS, progress, buffered)\n  }\n\n  play() {\n    !this._hls && this._setup()\n    !this._manifestParsed && !this.options.hlsPlayback.preload && this._hls.loadSource(this.options.src)\n\n    super.play()\n    this._startTimeUpdateTimer()\n  }\n\n  pause() {\n    if (!this._hls) return\n    this.el.pause()\n    if (this.dvrEnabled) this._updateDvr(true)\n  }\n\n  stop() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      super.stop()\n      this._hls.destroy()\n      delete this._hls\n    }\n  }\n\n  destroy() {\n    this._stopTimeUpdateTimer()\n    if (this._hls) {\n      this._hls.destroy()\n      delete this._hls\n    }\n    super.destroy()\n  }\n\n  _updatePlaybackType(evt, data) {\n    this._playbackType = data.details.live ? Playback.LIVE : Playback.VOD\n    this._onLevelUpdated(evt, data)\n\n    // Live stream subtitle tracks detection hack (may not immediately available)\n    if (this._ccTracksUpdated && this._playbackType === Playback.LIVE && this.hasClosedCaptionsTracks)\n      this._onSubtitleLoaded()\n\n  }\n\n  _fillLevels() {\n    this._levels = this._hls.levels.map((level, index) => {\n      return { id: index, level: level, label: `${level.bitrate/1000}Kbps` }\n    })\n    this.trigger(Events.PLAYBACK_LEVELS_AVAILABLE, this._levels)\n  }\n\n  _onLevelUpdated(evt, data) {\n    this._segmentTargetDuration = data.details.targetduration\n    this._playlistType = data.details.type || null\n\n    let startTimeChanged = false\n    let durationChanged = false\n    let fragments = data.details.fragments\n    let previousPlayableRegionStartTime = this._playableRegionStartTime\n    let previousPlayableRegionDuration = this._playableRegionDuration\n\n    if (fragments.length === 0)\n      return\n\n\n    // #EXT-X-PROGRAM-DATE-TIME\n    if (fragments[0].rawProgramDateTime)\n      this._programDateTime = fragments[0].rawProgramDateTime\n\n\n    if (this._playableRegionStartTime !== fragments[0].start) {\n      startTimeChanged = true\n      this._playableRegionStartTime = fragments[0].start\n    }\n\n    if (startTimeChanged) {\n      if (!this._localStartTimeCorrelation) {\n        // set the correlation to map to middle of the extrapolation window\n        this._localStartTimeCorrelation = {\n          local: this._now,\n          remote: (fragments[0].start + (this._extrapolatedWindowDuration/2)) * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localStartTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window\n        let startTime = (corr.remote + timePassed) / 1000\n        if (startTime < fragments[0].start) {\n          // our start time is now earlier than the first chunk\n          // (maybe the chunk was removed early)\n          // reset correlation so that it sits at the beginning of the first available chunk\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: fragments[0].start * 1000\n          }\n        } else if (startTime > previousPlayableRegionStartTime + this._extrapolatedWindowDuration) {\n          // start time was past the end of the old extrapolation window (so would have been capped)\n          // see if now that time would be inside the window, and if it would be set the correlation\n          // so that it resumes from the time it was at at the end of the old window\n          // update the correlation so that the time starts counting again from the value it's on now\n          this._localStartTimeCorrelation = {\n            local: this._now,\n            remote: Math.max(fragments[0].start, previousPlayableRegionStartTime + this._extrapolatedWindowDuration) * 1000\n          }\n        }\n      }\n    }\n\n    let newDuration = data.details.totalduration\n    // if it's a live stream then shorten the duration to remove access\n    // to the area after hlsjs's live sync point\n    // seeks to areas after this point sometimes have issues\n    if (this._playbackType === Playback.LIVE) {\n      let fragmentTargetDuration = data.details.targetduration\n      let hlsjsConfig = this.options.playback.hlsjsConfig || {}\n      let liveSyncDurationCount = hlsjsConfig.liveSyncDurationCount || HLSJS.DefaultConfig.liveSyncDurationCount\n      let hiddenAreaDuration = fragmentTargetDuration * liveSyncDurationCount\n      if (hiddenAreaDuration <= newDuration) {\n        newDuration -= hiddenAreaDuration\n        this._durationExcludesAfterLiveSyncPoint = true\n      } else { this._durationExcludesAfterLiveSyncPoint = false }\n\n    }\n\n    if (newDuration !== this._playableRegionDuration) {\n      durationChanged = true\n      this._playableRegionDuration = newDuration\n    }\n\n    // Note the end time is not the playableRegionDuration\n    // The end time will always increase even if content is removed from the beginning\n    let endTime = fragments[0].start + newDuration\n    let previousEndTime = previousPlayableRegionStartTime + previousPlayableRegionDuration\n    let endTimeChanged = endTime !== previousEndTime\n    if (endTimeChanged) {\n      if (!this._localEndTimeCorrelation) {\n        // set the correlation to map to the end\n        this._localEndTimeCorrelation = {\n          local: this._now,\n          remote: endTime * 1000\n        }\n      } else {\n        // check if the correlation still works\n        let corr = this._localEndTimeCorrelation\n        let timePassed = this._now - corr.local\n        // this should point to a time within the extrapolation window from the end\n        let extrapolatedEndTime = (corr.remote + timePassed) / 1000\n        if (extrapolatedEndTime > endTime) {\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: endTime * 1000\n          }\n        } else if (extrapolatedEndTime < endTime - this._extrapolatedWindowDuration) {\n          // our extrapolated end time is now earlier than the extrapolation window from the actual end time\n          // (maybe a chunk became available early)\n          // reset correlation so that it sits at the beginning of the extrapolation window from the end time\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: (endTime - this._extrapolatedWindowDuration) * 1000\n          }\n        } else if (extrapolatedEndTime > previousEndTime) {\n          // end time was past the old end time (so would have been capped)\n          // set the correlation so that it resumes from the time it was at at the end of the old window\n          this._localEndTimeCorrelation = {\n            local: this._now,\n            remote: previousEndTime * 1000\n          }\n        }\n      }\n    }\n\n    // now that the values have been updated call any methods that use on them so they get the updated values\n    // immediately\n    durationChanged && this._onDurationChange()\n    startTimeChanged && this._onProgress()\n  }\n\n  _onFragmentChanged(evt, data) {\n    this.trigger(Events.Custom.PLAYBACK_FRAGMENT_CHANGED, data)\n  }\n\n  _onFragmentLoaded(evt, data) {\n    this.trigger(Events.PLAYBACK_FRAGMENT_LOADED, data)\n  }\n\n  _onSubtitleLoaded() {\n    // This event may be triggered multiple times\n    // Setup CC only once (disable CC by default)\n    if (!this._ccIsSetup) {\n      this.trigger(Events.PLAYBACK_SUBTITLE_AVAILABLE)\n      const trackId = this._playbackType === Playback.LIVE ? -1 : this.closedCaptionsTrackId\n      this.closedCaptionsTrackId = trackId\n      this._ccIsSetup = true\n    }\n  }\n\n  _onLevelSwitch(evt, data) {\n    if (!this.levels.length)\n      this._fillLevels()\n\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH_END)\n    this.trigger(Events.PLAYBACK_LEVEL_SWITCH, data)\n    let currentLevel = this._hls.levels[data.level]\n    if (currentLevel) {\n      // TODO should highDefinition be private and maybe have a read only accessor if it's used somewhere\n      this.highDefinition = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000)\n      this.trigger(Events.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinition)\n      this.trigger(Events.PLAYBACK_BITRATE, {\n        height: currentLevel.height,\n        width: currentLevel.width,\n        bandwidth: currentLevel.bitrate,\n        bitrate: currentLevel.bitrate,\n        level: data.level\n      })\n    }\n  }\n\n  get dvrEnabled() {\n    // enabled when:\n    // - the duration does not include content after hlsjs's live sync point\n    // - the playable region duration is longer than the configured duration to enable dvr after\n    // - the playback type is LIVE.\n    return (this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === Playback.LIVE)\n  }\n\n  getPlaybackType() {\n    return this._playbackType\n  }\n\n  isSeekEnabled() {\n    return (this._playbackType === Playback.VOD || this.dvrEnabled)\n  }\n}\n\nHlsjsPlayback.canPlay = function(resource, mimeType) {\n  const resourceParts = resource.split('?')[0].match(/.*\\.(.*)$/) || []\n  const isHls = ((resourceParts.length > 1 && resourceParts[1].toLowerCase() === 'm3u8') || listContainsIgnoreCase(mimeType, ['application/vnd.apple.mpegurl', 'application/x-mpegURL']))\n\n  return !!(HLSJS.isSupported() && isHls)\n}\n"],"names":["now","Utils","assign","listContainsIgnoreCase","register","HlsjsPlayback","args","options","playback","_this","hlsPlayback","defaultOptions","_minDvrSize","hlsMinimumDvrSize","_extrapolatedWindowNumSegments","extrapolatedWindowNumSegments","_playbackType","Playback","VOD","_lastTimeUpdate","current","total","_lastDuration","_playableRegionStartTime","_localStartTimeCorrelation","_localEndTimeCorrelation","_playableRegionDuration","_programDateTime","_durationExcludesAfterLiveSyncPoint","_segmentTargetDuration","_playlistType","_recoverAttemptsRemaining","hlsRecoverAttempts","HLSJS","min","this","_levels","_currentLevel","undefined","id","trigger","Events","PLAYBACK_LEVEL_SWITCH_START","hlsUseNextLevel","_hls","nextLevel","currentLevel","_isReadyState","LIVE","_extrapolatedStartTime","corr","timePassed","_now","local","extrapolatedWindowStartTime","remote","Math","_extrapolatedWindowDuration","actualEndTime","extrapolatedEndTime","max","_extrapolatedEndTime","_startTime","bandwidthEstimate","preload","customListeners","_manifestParsed","_ccIsSetup","_ccTracksUpdated","destroy","hlsjsConfig","once","MEDIA_ATTACHED","_this2","loadSource","src","on","MANIFEST_PARSED","LEVEL_LOADED","evt","data","_updatePlaybackType","LEVEL_UPDATED","_onLevelUpdated","LEVEL_SWITCHING","_onLevelSwitch","FRAG_CHANGED","_onFragmentChanged","FRAG_LOADED","_onFragmentLoaded","FRAG_PARSING_METADATA","_onFragmentParsingMetadata","ERROR","_onHLSJSError","SUBTITLE_TRACK_LOADED","_onSubtitleLoaded","SUBTITLE_TRACKS_UPDATED","bindCustomListeners","attachMedia","el","forEach","item","requestedEventName","eventName","typeOfListener","_this3","callback","_this4","off","Custom","PLAYBACK_FRAGMENT_PARSING_METADATA","_ready","_setup","PLAYBACK_READY","name","error","_recoveredDecodingError","_recoveredAudioCodecError","Log","level","PlayerError","Levels","FATAL","formattedError","createError","PLAYBACK_ERROR","stop","swapAudioCodec","recoverMediaError","srcUrl","_timeUpdateTimer","setInterval","_this5","_onDurationChange","_onTimeUpdate","clearInterval","_duration","currentTime","percentage","seekTo","seek","time","warn","getDuration","dvrEnabled","_updateDvr","status","PLAYBACK_DVR","PLAYBACK_STATS_ADD","settings","left","seekEnabled","isSeekEnabled","PLAYBACK_SETTINGSUPDATE","code","type","details","description","raw","response","JSON","stringify","fatal","ErrorTypes","NETWORK_ERROR","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","MANIFEST_PARSING_ERROR","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","WARN","startLoad","MEDIA_ERROR","_recover","triggerFatalErrorOnResourceDenied","_keyIsDenied","KEY_LOAD_ERROR","update","getCurrentTime","firstFragDateTime","getProgramDateTime","PLAYBACK_TIMEUPDATE","duration","buffered","length","bufferedPos","i","start","end","progress","PLAYBACK_PROGRESS","_startTimeUpdateTimer","pause","_stopTimeUpdateTimer","live","hasClosedCaptionsTracks","levels","map","index","label","bitrate","PLAYBACK_LEVELS_AVAILABLE","targetduration","startTimeChanged","durationChanged","fragments","previousPlayableRegionStartTime","previousPlayableRegionDuration","rawProgramDateTime","startTime","newDuration","totalduration","hiddenAreaDuration","liveSyncDurationCount","DefaultConfig","endTime","previousEndTime","_onProgress","PLAYBACK_FRAGMENT_CHANGED","PLAYBACK_FRAGMENT_LOADED","PLAYBACK_SUBTITLE_AVAILABLE","trackId","closedCaptionsTrackId","_fillLevels","PLAYBACK_LEVEL_SWITCH_END","PLAYBACK_LEVEL_SWITCH","highDefinition","height","PLAYBACK_HIGHDEFINITIONUPDATE","PLAYBACK_BITRATE","width","bandwidth","getPlaybackType","HTML5Video","canPlay","resource","mimeType","resourceParts","split","match","isHls","toLowerCase","isSupported"],"mappings":"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"}